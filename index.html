<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hamming Code (15,11) Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'JetBrains Mono', monospace;
        }

        .bit-cell {
            transition: all 0.3s ease;
            cursor: pointer;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
        }
        
        .bit-cell:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px rgba(0,0,0,0.2);
        }

        /* Hover effect to show dependencies could be added here */
        .bit-cell:hover {
            filter: brightness(1.1);
        }

        .animate-pop {
            animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes pop {
            0% { transform: scale(0.9); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen p-4 flex flex-col items-center">

    <div class="max-w-4xl w-full space-y-8">
        
        <!-- Header -->
        <div class="text-center space-y-2">
            <h1 class="text-3xl font-bold text-emerald-400">Hamming Code (15,11) Visualizer</h1>
            <p class="text-slate-400">Click any bit to flip it (simulate data corruption). The parity logic will hunt it down.</p>
        </div>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            
            <!-- Left: The Bit Grid -->
            <div class="bg-slate-800 p-6 rounded-xl border border-slate-700 shadow-2xl">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-bold">16-Bit Block</h2>
                    <div class="flex gap-2">
                        <button onclick="resetGrid()" class="px-3 py-1 text-sm bg-slate-700 hover:bg-slate-600 rounded transition">Reset (Clean)</button>
                        <button onclick="randomizeData()" class="px-3 py-1 text-sm bg-emerald-600 hover:bg-emerald-500 rounded transition">Randomize Data</button>
                    </div>
                </div>

                <div class="grid grid-cols-4 gap-3 md:gap-4 aspect-square" id="grid-container">
                    <!-- Grid generated by JS -->
                </div>

                <div class="mt-6 flex flex-wrap gap-4 text-xs md:text-sm justify-center">
                    <div class="flex items-center gap-2"><div class="w-4 h-4 bg-slate-600 rounded"></div> Data Bit</div>
                    <div class="flex items-center gap-2"><div class="w-4 h-4 bg-cyan-700 rounded"></div> Parity Bit</div>
                    <div class="flex items-center gap-2"><div class="w-4 h-4 border-2 border-red-500 rounded"></div> Detected Error</div>
                </div>
            </div>

            <!-- Right: The Logic/Diagnostics -->
            <div class="space-y-6">
                
                <!-- Status Panel -->
                <div id="status-panel" class="bg-slate-800 p-6 rounded-xl border border-slate-700 transition-colors duration-300">
                    <h2 class="text-xl font-bold mb-2">System Status</h2>
                    <div id="status-message" class="text-lg">Initialized.</div>
                </div>

                <!-- Parity Breakdown -->
                <div class="bg-slate-800 p-6 rounded-xl border border-slate-700">
                    <h3 class="font-bold text-slate-300 mb-4 border-b border-slate-700 pb-2">Parity Check Breakdown</h3>
                    <div class="space-y-3 text-sm" id="parity-details">
                        <!-- Details injected by JS -->
                    </div>
                </div>

                <!-- How it works -->
                <div class="bg-slate-800/50 p-4 rounded-xl border border-slate-700 text-sm text-slate-400">
                    <p class="mb-2"><strong class="text-slate-200">The Math:</strong></p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>Positions 1, 2, 4, 8 are <span class="text-cyan-400">Parity Bits</span>.</li>
                        <li>Position 0 is the <span class="text-blue-400">Overall Parity</span> (checks all bits).</li>
                        <li>If a parity group has an odd number of 1s, it flags the <strong>Syndrome</strong>.</li>
                        <li>Syndrome = P8*8 + P4*4 + P2*2 + P1*1.</li>
                        <li>Combined with Overall Parity, we can detect 1-bit or 2-bit errors.</li>
                    </ul>
                </div>

            </div>
        </div>
    </div>

    <script>
        // Configuration
        const TOTAL_BITS = 16;
        const PARITY_POSITIONS = [1, 2, 4, 8]; // Powers of 2
        // Position 0 is usually overall parity in extended Hamming, we will include it in logic but focus on 1-15 correction
        
        let bits = new Array(TOTAL_BITS).fill(0);

        // Indices covered by each parity bit (standard Hamming construction)
        // P1 covers binary xxxx1 (1, 3, 5, 7, 9, 11, 13, 15)
        // P2 covers binary xxx1x (2, 3, 6, 7, 10, 11, 14, 15)
        // P4 covers binary xx1xx (4, 5, 6, 7, 12, 13, 14, 15)
        // P8 covers binary x1xxx (8, 9, 10, 11, 12, 13, 14, 15)
        const parityGroups = {
            1: [1, 3, 5, 7, 9, 11, 13, 15],
            2: [2, 3, 6, 7, 10, 11, 14, 15],
            4: [4, 5, 6, 7, 12, 13, 14, 15],
            8: [8, 9, 10, 11, 12, 13, 14, 15]
        };

        function init() {
            randomizeData();
        }

        function isParityBit(index) {
            return PARITY_POSITIONS.includes(index) || index === 0;
        }

        // Calculate correct parity bits based on current data bits
        function recalculateParityBits() {
            // We only calculate parity for indices 1, 2, 4, 8 based on data
            // We do NOT change data bits here, this is for the "Correct" state
            // NOTE: In this simulation, we don't auto-fix the parity bits after initialization
            // because we want the user to be able to break them.
            // This function is used strictly during 'Reset' or 'Randomize'.
            
            // 1. Clear parity bits
            PARITY_POSITIONS.forEach(p => bits[p] = 0);
            bits[0] = 0;

            // 2. Calculate P1, P2, P4, P8
            PARITY_POSITIONS.forEach(p => {
                let count = 0;
                parityGroups[p].forEach(index => {
                    // Start checking from the parity bit itself (which is currently 0)
                    // The standard algorithm: Sum of all bits in group must be even (0).
                    // So Parity Bit = XOR sum of Data Bits in group.
                    if (index !== p && bits[index] === 1) count++;
                });
                bits[p] = (count % 2 === 0) ? 0 : 1;
            });

            // 3. Optional: Calculate overall parity (bit 0)
            let totalSum = 0;
            for(let i=1; i<16; i++) totalSum += bits[i];
            bits[0] = (totalSum % 2 === 0) ? 0 : 1;
        }

        function randomizeData() {
            // Randomize only non-parity spots
            for (let i = 0; i < TOTAL_BITS; i++) {
                if (!isParityBit(i)) {
                    bits[i] = Math.random() > 0.5 ? 1 : 0;
                }
            }
            recalculateParityBits();
            render();
            checkErrors();
        }

        function resetGrid() {
            bits.fill(0);
            render();
            checkErrors();
        }

        function toggleBit(index) {
            bits[index] = bits[index] === 0 ? 1 : 0;
            render();
            checkErrors();
        }

        function checkErrors() {
            let syndrome = 0;
            let logHTML = "";
            let overallSum = 0;

            // 1. Check Standard Hamming Groups (Syndrome Calculation)
            PARITY_POSITIONS.forEach(p => {
                let sum = 0;
                parityGroups[p].forEach(idx => sum += bits[idx]);
                
                const isOdd = sum % 2 !== 0;
                const statusColor = isOdd ? "text-red-400 font-bold" : "text-emerald-400";
                const statusText = isOdd ? "FAIL (Odd)" : "PASS (Even)";
                
                if (isOdd) {
                    syndrome += p;
                }

                logHTML += `
                    <div class="flex justify-between items-center border-b border-slate-700/50 pb-1">
                        <span><span class="text-cyan-400 font-bold">P${p}</span> checks: ${parityGroups[p].join(', ')}</span>
                        <span class="${statusColor}">${statusText}</span>
                    </div>
                `;
            });

            // 2. Check Overall Parity (Bit 0 covers everything)
            bits.forEach(b => overallSum += b);
            const overallParityFail = overallSum % 2 !== 0;

            logHTML += `
                <div class="flex justify-between items-center border-b border-slate-700/50 pb-1 mt-2">
                    <span><span class="text-blue-400 font-bold">P0</span> (Overall): All Bits</span>
                    <span class="${overallParityFail ? 'text-red-400 font-bold' : 'text-emerald-400'}">${overallParityFail ? 'FAIL (Odd)' : 'PASS (Even)'}</span>
                </div>
            `;

            // 3. Determine Error State based on Syndrome + Overall Parity
            const statusPanel = document.getElementById('status-panel');
            const statusMessage = document.getElementById('status-message');
            
            // Clear highlights
            document.querySelectorAll('.bit-cell').forEach(el => {
                el.classList.remove('ring-4', 'ring-red-500', 'z-10');
            });

            if (syndrome === 0 && !overallParityFail) {
                // CASE: NO ERROR
                statusPanel.className = "bg-emerald-900/20 p-6 rounded-xl border border-emerald-500/50 transition-colors duration-300";
                statusMessage.innerHTML = `<span class="text-emerald-400">✓ Data Integrity Verified. No errors.</span>`;
            
            } else if (syndrome !== 0 && overallParityFail) {
                // CASE: SINGLE ERROR (Correctable)
                statusPanel.className = "bg-red-900/20 p-6 rounded-xl border border-red-500/50 transition-colors duration-300 animate-pulse";
                statusMessage.innerHTML = `
                    <div class="flex flex-col">
                        <span class="text-red-400 font-bold">⚠ SINGLE BIT ERROR DETECTED</span>
                        <span class="text-sm mt-1">Syndrome: ${syndrome} | Overall Parity: Fail</span>
                        <span class="text-sm">Logic identifies Bit #${syndrome} as corrupted.</span>
                    </div>
                `;
                // Highlight the error cell
                const errorCell = document.getElementById(`cell-${syndrome}`);
                if (errorCell) errorCell.classList.add('ring-4', 'ring-red-500', 'z-10');

            } else if (syndrome === 0 && overallParityFail) {
                // CASE: ERROR AT BIT 0
                statusPanel.className = "bg-red-900/20 p-6 rounded-xl border border-red-500/50 transition-colors duration-300 animate-pulse";
                statusMessage.innerHTML = `
                    <div class="flex flex-col">
                        <span class="text-red-400 font-bold">⚠ PARITY BIT ERROR</span>
                        <span class="text-sm mt-1">Syndrome: 0 | Overall Parity: Fail</span>
                        <span class="text-sm">The Overall Parity Bit (Bit #0) is corrupted.</span>
                    </div>
                `;
                 // Highlight Bit 0
                 const errorCell = document.getElementById(`cell-0`);
                 if (errorCell) errorCell.classList.add('ring-4', 'ring-red-500', 'z-10');

            } else if (syndrome !== 0 && !overallParityFail) {
                // CASE: DOUBLE ERROR (Uncorrectable)
                statusPanel.className = "bg-orange-900/20 p-6 rounded-xl border border-orange-500/50 transition-colors duration-300";
                statusMessage.innerHTML = `
                    <div class="flex flex-col">
                        <span class="text-orange-400 font-bold">⚠ DOUBLE BIT ERROR DETECTED</span>
                        <span class="text-sm mt-1">Syndrome: ${syndrome} | Overall Parity: OK</span>
                        <span class="text-sm">Two bits are flipped. Correction impossible. Location aliased to #${syndrome}.</span>
                    </div>
                `;
                // We do NOT highlight the cell because the syndrome points to the wrong place in a double error
            }

            document.getElementById('parity-details').innerHTML = logHTML;
        }

        function render() {
            const container = document.getElementById('grid-container');
            container.innerHTML = '';

            bits.forEach((bitVal, index) => {
                const el = document.createElement('div');
                el.id = `cell-${index}`;
                
                // Styling classes based on bit type
                let bgClass = "bg-slate-600"; // Data default
                let textClass = "text-slate-200";
                let label = "D";

                if (index === 0) {
                    bgClass = "bg-blue-900";
                    label = "OP"; // Overall Parity
                } else if (PARITY_POSITIONS.includes(index)) {
                    bgClass = "bg-cyan-700";
                    label = `P${index}`;
                }

                // If bit is 1, make it slightly brighter/different to indicate value visually beyond the number
                if (bitVal === 1) {
                    textClass = "text-white font-bold";
                } else {
                    textClass = "text-slate-400";
                }

                el.className = `bit-cell ${bgClass} rounded-lg flex flex-col items-center justify-center relative select-none animate-pop`;
                el.onclick = () => toggleBit(index);

                el.innerHTML = `
                    <span class="absolute top-1 left-2 text-[10px] uppercase opacity-50 tracking-wider">${index}</span>
                    <span class="text-4xl ${textClass}">${bitVal}</span>
                    <span class="absolute bottom-1 right-2 text-[10px] text-cyan-300 opacity-70">${label}</span>
                `;

                container.appendChild(el);
            });
        }

        // Start
        init();

    </script>
</body>
</html>